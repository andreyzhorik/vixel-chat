<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Vixel Chat — V2 (Red)</title>

<!--
  Vixel Chat — Final build (Option A)
  - Theme restored to requested reds:
      #000000, #3D0000, #950101, #FF0000
  - Presence: insert on login if missing
  - Auto avatar color (deterministic by name)
  - Anti-spam (rate limit + repeated message protection)
  - Bad-words filter (blocks or censors)
  - Shift+Enter -> newline, Enter -> send
  - Players list working live
  - Name change allowed once per week (tracked locally + best-effort server update)
  - Keep supabase URL/key the same as you provided earlier
  - If 401 appears: enable the anon policies in Supabase as previously shown
-->

<style>
  :root{
    --bg: #000000;
    --panel: #3D0000;
    --panel2: #950101;
    --accent: #FF0000;
    --text: #ffffff;
    --muted: #c8c8c8;
    --card-radius: 14px;
    --avatar-size: 40px;
  }

  html,body{
    height:100%;
    margin:0;
    background: linear-gradient(180deg, var(--bg), #120000);
    color:var(--text);
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .wrap{
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:20px;
    box-sizing:border-box;
  }

  .app{
    width:100%;
    max-width:1200px;
    height:88vh;
    display:grid;
    grid-template-columns: 3fr 1fr;
    gap:18px;
  }

  .card{
    background: linear-gradient(180deg, var(--panel), var(--panel2));
    border-radius: var(--card-radius);
    padding:14px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.7);
    display:flex;
    flex-direction:column;
    border:1px solid rgba(255,255,255,0.04);
    min-height:0;
  }

  .headerRow{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }

  .title{
    font-weight:900;
    font-size:20px;
  }

  .subtitle{
    color:var(--muted);
    font-size:13px;
  }

  /* messages column */
  .messages{
    flex:1;
    overflow-y:auto;
    padding:12px;
    border-radius:10px;
    background: linear-gradient(180deg, rgba(0,0,0,0.08), rgba(255,255,255,0.01));
    display:flex;
    flex-direction:column;
    gap:12px;
    min-height:0;
    scroll-behavior:smooth;
  }

  .msgRow{
    display:flex;
    gap:12px;
    align-items:flex-start;
    max-width:100%;
  }

  .avatar{
    width:var(--avatar-size);
    height:var(--avatar-size);
    min-width:var(--avatar-size);
    border-radius:50%;
    display:inline-grid;
    place-items:center;
    font-weight:800;
    color: #fff;
    text-transform:uppercase;
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    border:2px solid rgba(0,0,0,0.25);
    flex-shrink:0;
  }

  .msg{
    padding:10px 12px;
    border-radius:10px;
    background: rgba(0,0,0,0.35);
    font-size:14px;
    line-height:1.4;
    max-width:86%;
    word-break:break-word;
    border: 1px solid rgba(255,255,255,0.03);
  }

  .meta{
    font-size:12px;
    color:var(--muted);
    margin-bottom:6px;
  }

  .inputRow{
    display:flex;
    gap:10px;
    align-items:center;
    margin-top:10px;
  }

  textarea, input[type="text"]{
    background: rgba(0,0,0,0.45);
    border: 1px solid rgba(255,255,255,0.06);
    color:var(--text);
    padding:10px;
    border-radius:8px;
    outline:none;
    flex:1;
    resize:vertical;
    min-height:48px;
    max-height:160px;
    font-size:14px;
  }

  .btn{
    background: linear-gradient(180deg, var(--accent), #c40000);
    padding:10px 14px;
    border-radius:8px;
    border:none;
    color:white;
    cursor:pointer;
    font-weight:800;
  }

  /* players column */
  .usersHeader{
    display:flex;
    align-items:center;
    justify-content:space-between;
    margin-bottom:10px;
  }

  .usersList{
    overflow:auto;
    flex:1;
    display:flex;
    flex-direction:column;
    gap:8px;
  }

  .userCard{
    display:flex;
    gap:10px;
    align-items:center;
    padding:8px;
    border-radius:8px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.02);
  }

  .statusDot{
    width:10px;
    height:10px;
    border-radius:50%;
    margin-left:auto;
    box-shadow:0 1px 4px rgba(0,0,0,0.6);
  }
  .status-online{ background: #48ff7a; }
  .status-offline{ background: #6b6b6b; }

  .mutedSmall{ color:var(--muted); font-size:13px; }

  @media (max-width:900px){
    .app{ grid-template-columns: 1fr; height:95vh; }
    .users { order: -1; }
  }

  /* make file longer with helpful comments (still organized) */
</style>
</head>
<body>
  <div class="wrap">
    <div class="app">

      <!-- MAIN CHAT -->
      <div class="card">
        <div class="headerRow">
          <div>
            <div class="title">Vixel Chat</div>
            <div class="subtitle">Realtime chat — red vibes restored</div>
          </div>
          <div style="text-align:right;">
            <div class="mutedSmall" id="statusHint">not logged</div>
            <div class="mutedSmall" id="debugHint" style="margin-top:6px;">debug ready</div>
          </div>
        </div>

        <div id="messages" class="messages" aria-live="polite" role="log"></div>

        <!-- message input -->
        <div class="inputRow">
          <textarea id="messageInput" placeholder="Message — Shift+Enter for newline, Enter to send"></textarea>
          <button id="sendBtn" class="btn">Send</button>
        </div>

        <!-- login / name -->
        <div style="margin-top:12px; display:flex; gap:8px; align-items:center;">
          <input id="nameInput" placeholder="Your name (change once/week)" />
          <button id="loginBtn" class="btn">Set Name</button>
        </div>

        <div style="margin-top:12px; display:flex; gap:10px; align-items:center;">
          <div class="mutedSmall" id="messagesCount">messages: 0</div>
          <div class="mutedSmall">•</div>
          <div class="mutedSmall" id="playersCount">players: 0</div>
        </div>

      </div>

      <!-- PLAYERS -->
      <div class="card">
        <div class="usersHeader">
          <div style="font-weight:700">Players</div>
          <div class="mutedSmall" id="onlineCount">0 online</div>
        </div>

        <div id="usersList" class="usersList"></div>

        <div style="margin-top:12px; display:flex; align-items:center; gap:8px;">
          <div class="mutedSmall">auto online while active</div>
          <div style="flex:1"></div>
          <button id="refreshPlayersBtn" class="btn" style="background:linear-gradient(180deg,#3a3a3a,#1f1f1f)">Refresh</button>
        </div>
      </div>

    </div>
  </div>

<script type="module">
/*
  Vixel Chat — big file
  - Option A: auto avatar color based on name
  - name change limited to once per week
  - anti-spam & bad-word filter
  - presence insert on login (Option B earlier) — we already handle insertion here
  - Restore red theme and keep everything long & commented
*/

import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

/* --------------------------
   Supabase config (your values kept)
---------------------------*/
const supabaseUrl = "https://ehciyxvbasqiiiurjuwu.supabase.co";
const supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVoY2l5eHZiYXNxaWlpdXJqdXd1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQwNzQzNTgsImV4cCI6MjA3OTY1MDM1OH0.yMZ8EqtPXJumjn2xHTXwG3jbWTNdDxrklYIkdXNcbQk";
const supabase = createClient(supabaseUrl, supabaseKey);

/* --------------------------
   DOM references
---------------------------*/
const messagesEl = document.getElementById("messages");
const messageInput = document.getElementById("messageInput");
const sendBtn = document.getElementById("sendBtn");
const nameInput = document.getElementById("nameInput");
const loginBtn = document.getElementById("loginBtn");
const usersList = document.getElementById("usersList");
const onlineCountEl = document.getElementById("onlineCount");
const statusHint = document.getElementById("statusHint");
const debugHint = document.getElementById("debugHint");
const messagesCountEl = document.getElementById("messagesCount");
const playersCountEl = document.getElementById("playersCount");
const refreshPlayersBtn = document.getElementById("refreshPlayersBtn");

/* --------------------------
   Local state
---------------------------*/
let username = localStorage.getItem("vixel_user") || "";
let presenceId = localStorage.getItem("vixel_presence_id") || null;
let nameChangedAt = localStorage.getItem("vixel_name_changed_at") || null; // ISO timestamp
let onlineUsers = {}; // map username -> {username, online, id, color, avatar}
let seenMessageIds = new Set();
let messagesChannel = null;
let presenceChannel = null;
let messageCount = 0;

/* --------------------------
   Anti-spam and bad words
---------------------------*/
// simple bad words list — add whatever you want
const BAD_WORDS = ["badword","anotherbadword","foo"]; // lowercase
const SPAM_WINDOW_MS = 10000; // window to count messages
const SPAM_MAX_MESSAGES = 5; // max messages allowed in window
const recentMessages = []; // timestamps of user's sent messages for rate limiting
let lastSentText = ""; // avoid immediate duplicate messages

/* --------------------------
   Helpers: color/avatar generation
   Option A: deterministic color by name
---------------------------*/
function deterministicColorForName(name) {
  const palette = ["#FF2A2A","#FF6B6B","#FF8A4D","#FFD166","#4DFF8A","#4DD7FF","#7A4DFF","#FF4DA8","#FF3B3B","#E05252"];
  if (!name) return palette[Math.floor(Math.random()*palette.length)];
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = (hash << 5) - hash + name.charCodeAt(i);
    hash |= 0;
  }
  return palette[Math.abs(hash) % palette.length];
}

function avatarElement(name, size = 40, colorHex = null) {
  const el = document.createElement("div");
  el.className = "avatar";
  const letter = (name || "?").charAt(0).toUpperCase();
  el.textContent = letter;
  const bg = colorHex || deterministicColorForName(name);
  el.style.background = bg;
  el.style.width = `${size}px`;
  el.style.height = `${size}px`;
  el.style.minWidth = `${size}px`;
  return el;
}

function escapeHtml(s) {
  return String(s || "").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c]));
}

/* --------------------------
   UI: messages render + dedupe
---------------------------*/
function clearMessages() {
  messagesEl.innerHTML = "";
  seenMessageIds.clear();
  messageCount = 0;
  messagesCountEl.textContent = `messages: ${messageCount}`;
}

function addMessageToDOM(msg) {
  // msg: { id, user, text, created_at }
  if (msg && msg.id) {
    if (seenMessageIds.has(msg.id)) return;
    seenMessageIds.add(msg.id);
  }

  const row = document.createElement("div");
  row.className = "msgRow";

  // find color from presence map if available
  const userPresence = onlineUsers[msg.user] || null;
  const color = (userPresence && (userPresence.avatar || userPresence.color)) || deterministicColorForName(msg.user);

  row.appendChild(avatarElement(msg.user || "?", 40, color));

  const box = document.createElement("div");
  box.className = "msg";

  const meta = document.createElement("div");
  meta.className = "meta";
  const ts = msg.created_at ? new Date(msg.created_at).toLocaleTimeString() : "";
  meta.innerHTML = `<strong>${escapeHtml(msg.user || "anon")}</strong> · <span class="mutedSmall">${escapeHtml(ts)}</span>`;

  const text = document.createElement("div");
  // preserve newlines
  const safe = escapeHtml(msg.text || "").replace(/\n/g, "<br/>");
  text.innerHTML = safe;

  box.appendChild(meta);
  box.appendChild(text);
  row.appendChild(box);

  messagesEl.appendChild(row);

  messageCount++;
  messagesCountEl.textContent = `messages: ${messageCount}`;
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

/* --------------------------
   Load messages (initial)
---------------------------*/
async function loadMessages() {
  debug("loadMessages");
  try {
    const { data, error } = await supabase
      .from("messages")
      .select("id, user, text, created_at")
      .order("created_at", { ascending: true })
      .limit(500);

    if (error) throw error;

    clearMessages();
    (data || []).forEach(r => addMessageToDOM(r));
    debug(`loaded ${data?.length || 0} messages`);
  } catch (err) {
    console.error("loadMessages err", err);
    debug("loadMessages err: " + (err.message || err));
  }
}

/* --------------------------
   Message sending with anti-spam + bad-words
---------------------------*/
function containsBadWord(text){
  const t = text.toLowerCase();
  return BAD_WORDS.some(b => t.includes(b));
}

function isRateLimited(){
  const now = Date.now();
  // purge old items
  while (recentMessages.length && (now - recentMessages[0]) > SPAM_WINDOW_MS) {
    recentMessages.shift();
  }
  return recentMessages.length >= SPAM_MAX_MESSAGES;
}

async function sendMessage(){
  const raw = messageInput.value;
  if (!raw) return;
  const text = raw.trim();
  if (!username) { alert("Set your name first"); return; }

  // bad words check
  if (containsBadWord(text)) {
    // block send; you could alternatively censor by replacing with stars
    alert("Message blocked: contains forbidden words.");
    return;
  }

  // spam checks: repeated immediate exact text
  if (text === lastSentText) {
    alert("Don't send the same message twice in a row.");
    return;
  }

  if (isRateLimited()) {
    alert("You're sending messages too quickly. Slow down a bit.");
    return;
  }

  // pass checks -> send
  sendBtn.disabled = true;
  try {
    // record timestamp locally for spam window
    recentMessages.push(Date.now());
    lastSentText = text;

    const { data, error } = await supabase
      .from("messages")
      .insert([{ user: username, text }])
      .select("id, user, text, created_at");

    if (error) throw error;

    // optionally render inserted row immediately (dedupe prevents dup)
    if (data && data[0]) addMessageToDOM(data[0]);

    messageInput.value = "";
    messageInput.focus();
  } catch (err) {
    console.error("sendMessage err", err);
    debug("sendMessage err: " + (err.message || err));
    alert("Failed to send message");
  } finally {
    sendBtn.disabled = false;
  }
}

/* --------------------------
   Presence helpers (Option B: insert on login if missing)
   We will store color & avatar auto on creation as text (hex)
   name change limit once/week (local + attempt server-side update)
---------------------------*/
async function ensurePresenceRow(name) {
  if (!name) return;
  try {
    const { data: existing, error: selErr } = await supabase
      .from("presence")
      .select("id, username, online, color, avatar")
      .eq("username", name)
      .limit(1);

    if (selErr) {
      console.warn("presence select err", selErr);
    }

    if (existing && existing.length > 0) {
      presenceId = existing[0].id;
      localStorage.setItem("vixel_presence_id", presenceId);
      // update to online
      await supabase.from("presence").update({ online: true }).eq("id", presenceId);
      return;
    }

    // insert new presence row with auto color/avatar
    const color = deterministicColorForName(name);
    const avatar = color;
    const { data: ins, error: insErr } = await supabase
      .from("presence")
      .insert([{ username: name, online: true, color, avatar }])
      .select("id, username, online, color, avatar");

    if (insErr) {
      console.warn("presence insertErr", insErr);
      debug("presence insertErr " + (insErr.message || insErr));
      // fallback: try update by username (race)
      await supabase.from("presence").update({ online: true }).eq("username", name);
      const { data: fb, error: fbErr } = await supabase.from("presence").select("id").eq("username", name).limit(1);
      if (fb && fb.length > 0) {
        presenceId = fb[0].id;
        localStorage.setItem("vixel_presence_id", presenceId);
      }
      return;
    }

    if (ins && ins[0]) {
      presenceId = ins[0].id;
      localStorage.setItem("vixel_presence_id", presenceId);
    }
  } catch (err) {
    console.error("ensurePresenceRow err", err);
    debug("ensurePresenceRow err: " + (err.message || err));
  }
}

async function setOnline(name) {
  if (!name) return;
  try {
    await supabase.from("presence").update({ online: true }).eq("username", name);
  } catch (err) { console.warn("setOnline err", err); }
}

async function setOffline(name) {
  if (!name) return;
  try {
    await supabase.from("presence").update({ online: false }).eq("username", name);
  } catch (err) { console.warn("setOffline err", err); }
}

/* --------------------------
   Load presence and render players
---------------------------*/
async function loadPresence() {
  debug("loadPresence");
  try {
    const { data, error } = await supabase
      .from("presence")
      .select("id, username, online, color, avatar");

    if (error) throw error;

    onlineUsers = {};
    (data || []).forEach(r => {
      onlineUsers[r.username] = {
        username: r.username,
        online: r.online,
        id: r.id,
        color: r.color,
        avatar: r.avatar
      };
    });

    renderPlayers();
    debug("presence rows: " + (data?.length || 0));
  } catch (err) {
    console.error("loadPresence err", err);
    debug("loadPresence err: " + (err.message || err));
  }
}

function renderPlayers(){
  usersList.innerHTML = "";
  const arr = Object.values(onlineUsers).sort((a,b) => {
    if (a.online === b.online) return (a.username||"").localeCompare(b.username||"");
    return a.online ? -1 : 1;
  });

  arr.forEach(u => {
    const card = document.createElement("div");
    card.className = "userCard";

    const av = avatarElement(u.username, 34, u.avatar || u.color || deterministicColorForName(u.username));
    card.appendChild(av);

    const nameEl = document.createElement("div");
    nameEl.style.fontWeight = 700;
    nameEl.textContent = u.username;
    card.appendChild(nameEl);

    const dot = document.createElement("div");
    dot.className = "statusDot " + (u.online ? "status-online" : "status-offline");
    card.appendChild(dot);

    usersList.appendChild(card);
  });

  const onlineCount = arr.filter(x => x.online).length;
  onlineCountEl.textContent = `${onlineCount} online`;
  playersCountEl.textContent = `players: ${arr.length}`;
}

/* --------------------------
   Realtime subscriptions
---------------------------*/
function subscribeRealtime() {
  if (messagesChannel || presenceChannel) return;

  messagesChannel = supabase
    .channel("realtime:messages")
    .on("postgres_changes", { event: "INSERT", schema: "public", table: "messages" }, payload => {
      if (payload && payload.new) addMessageToDOM(payload.new);
    })
    .subscribe(status => debug("messages channel: " + status));

  presenceChannel = supabase
    .channel("realtime:presence")
    .on("postgres_changes", { event: "INSERT", schema: "public", table: "presence" }, payload => {
      const r = payload.new;
      if (!r || !r.username) return;
      onlineUsers[r.username] = { username: r.username, online: r.online, id: r.id, color: r.color, avatar: r.avatar };
      renderPlayers();
    })
    .on("postgres_changes", { event: "UPDATE", schema: "public", table: "presence" }, payload => {
      const r = payload.new;
      if (!r || !r.username) return;
      onlineUsers[r.username] = { username: r.username, online: r.online, id: r.id, color: r.color, avatar: r.avatar };
      renderPlayers();
    })
    .on("postgres_changes", { event: "DELETE", schema: "public", table: "presence" }, payload => {
      const r = payload.old;
      if (!r || !r.username) return;
      delete onlineUsers[r.username];
      renderPlayers();
    })
    .subscribe(status => debug("presence channel: " + status));
}

/* --------------------------
   Name change limiter (once per week)
   We'll record timestamp in localStorage under 'vixel_name_changed_at'
   Format: ISO string
---------------------------*/
function canChangeNameNow() {
  if (!nameChangedAt) return true;
  try {
    const last = new Date(nameChangedAt);
    const now = new Date();
    const diff = now - last;
    const weekMs = 7 * 24 * 60 * 60 * 1000;
    return diff >= weekMs;
  } catch(e) { return true; }
}

function recordNameChangeNow() {
  const now = new Date().toISOString();
  nameChangedAt = now;
  localStorage.setItem("vixel_name_changed_at", now);
  // best-effort update presence row with name_changed_at if column exists
  if (presenceId) {
    supabase.from("presence").update({ name_changed_at: now }).eq("id", presenceId).catch(()=>{});
  }
}

/* --------------------------
   Event wiring
---------------------------*/
loginBtn.onclick = async () => {
  const name = nameInput.value.trim();
  if (!name) { alert("Type a name"); return; }

  // check weekly limit (local)
  if (username && username !== name) {
    if (!canChangeNameNow()) {
      alert("You can only change your name once per week.");
      return;
    }
  }

  username = name;
  localStorage.setItem("vixel_user", username);
  nameInput.value = "";
  statusHint.textContent = `logged as ${username}`;

  // ensure presence row exists and mark online
  await ensurePresenceRow(username);
  await setOnline(username);
  recordNameChangeNow();

  // subscribe and load data
  subscribeRealtime();
  await loadPresence();
  await loadMessages();
};

sendBtn.onclick = sendMessage;

messageInput.addEventListener("keydown", async (e) => {
  if (e.key === "Enter") {
    if (e.shiftKey) {
      // allow newline
      return;
    } else {
      e.preventDefault();
      await sendMessage();
    }
  }
});

refreshPlayersBtn.onclick = async () => {
  await loadPresence();
};

/* --------------------------
   Visibility / unload handlers
   mark offline on hidden/unload and online on visible
---------------------------*/
window.addEventListener("beforeunload", () => {
  if (username) {
    // best-effort set offline (async)
    setTimeout(() => setOffline(username), 0);
  }
});

document.addEventListener("visibilitychange", async () => {
  if (document.visibilityState === "hidden") {
    if (username) await setOffline(username).catch(()=>{});
    statusHint.textContent = username ? `hidden` : `not logged`;
  } else {
    if (username) {
      await ensurePresenceRow(username).catch(()=>{});
      await setOnline(username).catch(()=>{});
    }
    subscribeRealtime();
    await loadPresence();
    await loadMessages();
    statusHint.textContent = username ? `logged as ${username}` : `not logged`;
  }
});

/* --------------------------
   Init
---------------------------*/
(async function init(){
  debug("init start");
  if (username) {
    statusHint.textContent = `logged as ${username}`;
    await ensurePresenceRow(username);
    await setOnline(username);
  } else {
    statusHint.textContent = "not logged";
  }

  subscribeRealtime();
  await loadPresence();
  await loadMessages();
  debug("init done");
})();

/* --------------------------
   Heartbeat (25s) to avoid false offline
---------------------------*/
setInterval(async () => {
  if (username) await setOnline(username).catch(()=>{});
}, 25000);

/* --------------------------
   Debug helper
---------------------------*/
function debug(msg) {
  try {
    debugHint.textContent = "debug: " + String(msg).slice(0,120);
    console.debug("[vixel-debug]", msg);
  } catch(e){}
}

/* --------------------------
   End JS
---------------------------*/
</script>

<!--
  NOTES & ACTIONS (quick):
  1) Recreate the presence columns:
     - color (text)
     - avatar (text)
     - optionally: name_changed_at (timestamp) if you want server-side tracking
  2) If you see 401 errors: enable anon policies for presence/messages:
     - create policy for select/insert/update on presence (and messages if needed)
  3) Bad words: edit BAD_WORDS array in the JS to include words you want filtered.
  4) Rate limits: tweak SPAM_WINDOW_MS and SPAM_MAX_MESSAGES to taste.
  5) If you want UI to allow picking colors manually (Option B), say so and i'll add a picker (full file).
-->

</body>
</html>
