<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vixel Chat</title>
<style>
  :root{
    --bg:#000000;
    --panel:#150000;
    --panel2:#1b0000;
    --accent1:#5A0000;
    --accent2:#C00000;
    --accent3:#FF2A2A;
    --text:#ffffff;
    --muted:#bbbbbb;
  }

  html,body{
    height:100%;
    margin:0;
    overflow:hidden; /* prevent page scroll; only messages scroll */
    background:linear-gradient(180deg,var(--bg),#1b0000);
    font-family:Inter,system-ui,Arial;
    color:var(--text);
  }

  .wrap{
    height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:18px;
    box-sizing:border-box;
  }

  .app{
    width:100%;
    max-width:1100px;
    height:80vh;
    display:grid;
    grid-template-columns:3fr 1fr;
    gap:18px;
    min-height:0;
  }

  .card{
    background:linear-gradient(180deg,var(--panel),var(--panel2));
    border-radius:14px;
    padding:12px;
    box-shadow:0 8px 30px rgba(0,0,0,0.7);
    display:flex;
    flex-direction:column;
    border:1px solid rgba(255,0,0,0.04);
    min-height:0; /* important for flex children to scroll */
  }

  .header{
    display:flex;
    align-items:center;
    gap:10px;
    margin-bottom:8px;
  }

  .logo{
    width:52px;
    height:52px;
    border-radius:10px;
    overflow:hidden;
    display:flex;
    align-items:center;
    justify-content:center;
    background:transparent;
  }
  .logo img{ width:100%; height:100%; object-fit:contain; }

  .title{font-size:20px;}
  .sub{color:var(--muted);font-size:13px;}

  /* ONLY messages scroll */
  .messages {
    flex:1;
    overflow-y:auto;
    padding:12px;
    border-radius:8px;
    background:rgba(0,0,0,0.20);
    display:flex;
    flex-direction:column;
    gap:8px;
    min-height:0; /* crucial */
    scroll-behavior:smooth;
  }

  .msg{
    max-width:78%;
    padding:10px 12px;
    border-radius:12px;
    display:flex;
    gap:10px;
    align-items:flex-start;
    background:rgba(255,255,255,0.03);
    box-shadow:0 6px 18px rgba(0,0,0,0.45);
    word-break:break-word;
    animation:pop .12s ease;
  }
  @keyframes pop { from{opacity:0; transform:translateY(6px) scale(.99);} to{opacity:1; transform:none;} }

  .avatar{ width:34px; height:34px; border-radius:8px; display:flex; align-items:center; justify-content:center; font-weight:700; color:#fff; background:var(--accent3); flex-shrink:0; }
  .meta{ font-weight:700; color:var(--muted); margin-bottom:4px; font-size:13px; }
  .text{ font-size:15px; color:#fff; line-height:1.35; }

  .msg.own{ margin-left:auto; background:linear-gradient(180deg, rgba(255,30,30,0.12), rgba(255,0,0,0.04)); border:1px solid rgba(255,0,0,0.08); }
  .msg.other{ margin-right:auto; background:linear-gradient(180deg, rgba(80,0,0,0.10), rgba(40,0,0,0.03)); border:1px solid rgba(255,255,255,0.02); }

  .time{ font-size:12px; color:var(--muted); margin-left:8px; align-self:flex-end; }

  .inputRow{
    display:flex;
    gap:8px;
    padding-top:10px;
  }

  input[type="text"]{
    background:transparent;
    border:1px solid rgba(255,255,255,0.12);
    color:var(--text);
    padding:10px;
    border-radius:8px;
    outline:none;
    flex:1;
  }

  .btn{
    background:linear-gradient(90deg,var(--accent2),var(--accent3));
    padding:10px 14px;
    border-radius:8px;
    border:none;
    color:white;
    cursor:pointer;
    font-weight:700;
  }

  .players{
    display:flex;
    flex-direction:column;
    gap:8px;
    height:100%;
  }

  .playerList{
    overflow:hidden; /* no scroll here; only messages scroll */
    flex:1;
    padding:6px;
    background:rgba(0,0,0,0.18);
    border-radius:8px;
  }

  .player{
    display:flex;
    align-items:center;
    gap:8px;
    padding:6px;
    border-radius:8px;
    background:rgba(255,255,255,0.02);
  }

  .dot{ width:10px; height:10px; border-radius:50%; }
  .dot.online{ background:var(--accent2); box-shadow:0 0 6px rgba(255,0,0,0.12); }
  .dot.offline{ background:#444; }

  .small{ color:var(--muted); font-size:13px; }

  @media(min-width:1100px){
    .logo{ width:64px; height:64px; border-radius:12px; }
    .avatar{ width:40px; height:40px; border-radius:10px; }
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="app">

    <!-- CHAT PANEL -->
    <div class="card" id="chatCard">
      <div class="header">
        <div class="logo"><img src="https://raw.githubusercontent.com/andreyzhorik/VIXEL/main/logonobg.png" alt="vixel"></div>
        <div>
          <div class="title">Vixel Chat</div>
          <div class="sub">server-backed â€” everyone sees messages</div>
        </div>
        <div style="margin-left:auto;" id="statusBadge" class="small">not connected</div>
      </div>

      <div id="messages" class="messages"></div>

      <div class="inputRow">
        <input id="messageInput" type="text" placeholder="Type a message..." autocomplete="off" />
        <button id="sendBtn" class="btn">Send</button>
      </div>

      <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
        <input id="nameInput" placeholder="your name" style="flex:1" />
        <button id="loginBtn" class="btn">Set Name</button>
      </div>
    </div>

    <!-- PLAYERS PANEL -->
    <div class="card players">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <strong>Players</strong>
        <div id="onlineCount" class="small">0 online</div>
      </div>
      <div id="playerList" class="playerList"></div>
    </div>

  </div>
</div>

<script>
/* config */
const WORKER_URL = "https://vixel-chat.mrviktor2426.workers.dev";
const POLL = 2000;      // fetch messages interval
const PRESENCE = 8000;  // presence heartbeat
const NAME_LIMIT = 7 * 24 * 60 * 60 * 1000; // 1 week name change cooldown

/* state */
let token = localStorage.getItem('vixel_token');
let username = localStorage.getItem('vixel_user');
let lastMsgId = ''; /* server uses string ids like ts:rand */

const messagesEl = document.getElementById('messages');
const playerListEl = document.getElementById('playerList');
const statusBadge = document.getElementById('statusBadge');
const msgInput = document.getElementById('messageInput');
const nameInput = document.getElementById('nameInput');

function escapeHtml(t){ return String(t||'').replace(/[&<>]/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[m])); }
function setStatus(t){ statusBadge.textContent = t; }

/* API helper */
async function API(path, method='GET', body=null){
  const headers = {'Accept':'application/json'};
  if(token) headers['Authorization'] = 'Bearer '+token;
  if(body) headers['Content-Type'] = 'application/json';
  const res = await fetch(WORKER_URL + path, { method, headers, body: body ? JSON.stringify(body) : null });
  if(!res.ok) throw new Error(await res.text());
  return res.json();
}

/* register (set name) with cooldown */
async function setName(){
  const name = nameInput.value.trim();
  if(!name) return alert('enter a name bro');
  const lastChange = Number(localStorage.getItem('vixel_last_name_change') || 0);
  if(lastChange && (Date.now() - lastChange) < NAME_LIMIT){
    const daysLeft = Math.ceil((NAME_LIMIT - (Date.now() - lastChange)) / (1000*60*60*24));
    return alert('you can change your name again in '+daysLeft+' day(s)');
  }
  try{
    const r = await API('/register','POST',{name});
    token = r.token;
    username = name;
    localStorage.setItem('vixel_token', token);
    localStorage.setItem('vixel_user', name);
    localStorage.setItem('vixel_last_name_change', Date.now());
    setStatus('connected as '+name);
    nameInput.value = '';
    await heartbeat(); // announce presence immediately
    fetchPlayers();
    fetchMessages();
  }catch(e){
    alert('register failed: '+e.message);
  }
}

/* send message to server */
async function sendMessage(){
  const text = msgInput.value.trim();
  if(!text) return;
  try{
    await API('/send','POST',{text});
    msgInput.value = '';
    // fetch new messages ASAP
    fetchMessages();
  }catch(e){
    alert('send failed: '+e.message);
  }
}

/* fetch messages after lastMsgId */
async function fetchMessages(){
  try{
    const q = lastMsgId ? '?after=' + encodeURIComponent(lastMsgId) : '';
    const r = await API('/messages' + q, 'GET');
    // r.messages contains filtered messages (after), r.all contains all
    if(r.messages && r.messages.length){
      // append only new messages to DOM (we'll render from r.all for simplicity)
      const all = r.all || [];
      lastMsgId = all.length ? all[all.length-1].id : lastMsgId;
      renderMessages(all);
    } else if(!lastMsgId && r.all && r.all.length){
      // initial load
      const all = r.all;
      lastMsgId = all[all.length-1].id;
      renderMessages(all);
    }
  }catch(e){
    console.error('fetchMessages err', e);
  }
}

/* render messages array (server-sent order) */
function renderMessages(arr){
  messagesEl.innerHTML = arr.map(m => {
    const own = (m.user === username);
    const cls = own ? 'msg own' : 'msg other';
    const avatar = escapeHtml((m.user||' ').charAt(0).toUpperCase() || '?');
    const time = new Date(m.ts).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});
    return `<div class="${cls}">
      <div class="avatar">${avatar}</div>
      <div style="display:flex;flex-direction:column;">
        <div class="meta">${escapeHtml(m.user)} <span class="time">${time}</span></div>
        <div class="text">${escapeHtml(m.text)}</div>
      </div>
    </div>`;
  }).join('');
  // keep scroll pinned to bottom if already near bottom
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

/* fetch players */
async function fetchPlayers(){
  try{
    const r = await API('/players','GET');
    const players = r.players || [];
    // sort by lastSeen desc (worker already does but safe)
    players.sort((a,b)=> (b.lastSeen||0) - (a.lastSeen||0));
    const now = Date.now();
    let onlineCount = 0;
    playerListEl.innerHTML = players.map(p=>{
      const isOnline = (now - (p.lastSeen||0)) < 20000;
      if(isOnline) onlineCount++;
      return `<div class="player">
        <div class="dot ${isOnline ? 'online' : 'offline'}"></div>
        <div class="avatar">${escapeHtml((p.name||' ').charAt(0).toUpperCase()||'?')}</div>
        <div style="display:flex;flex-direction:column;">
          <div style="font-weight:700">${escapeHtml(p.name)}</div>
          <div style="font-size:12px;color:var(--muted)">${isOnline ? 'online' : timeAgo(p.lastSeen)}</div>
        </div>
      </div>`;
    }).join('');
    document.getElementById('onlineCount').textContent = onlineCount + ' online';
  }catch(e){
    console.error('fetchPlayers err', e);
  }
}

/* presence heartbeat */
async function heartbeat(){
  try{
    if(!token) return;
    await API('/presence','POST', {});
  }catch(e){
    console.warn('presence err', e);
  }
}

/* util: time ago for player last seen */
function timeAgo(ts){
  if(!ts) return 'never';
  const s = Math.floor((Date.now() - ts) / 1000);
  if(s < 60) return `${s}s`;
  if(s < 3600) return `${Math.floor(s/60)}m`;
  if(s < 86400) return `${Math.floor(s/3600)}h`;
  return `${Math.floor(s/86400)}d`;
}

/* events */
document.getElementById('loginBtn').onclick = setName;
document.getElementById('sendBtn').onclick = sendMessage;
msgInput.addEventListener('keydown', e => { if(e.key==='Enter') sendMessage(); });

/* polling */
setInterval(fetchMessages, POLL);
setInterval(()=>{ heartbeat(); fetchPlayers(); }, PRESENCE);

/* init */
(async function(){
  if(token && username){
    setStatus('connected as '+username);
    // announce presence immediately
    await heartbeat();
    fetchMessages();
    fetchPlayers();
  } else {
    setStatus('not connected');
    // still can load messages publicly even if not registered
    fetchMessages();
    fetchPlayers();
  }
})();
</script>
</body>
</html>
