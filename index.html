<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vixel Chat — Full Build</title>

<!--
  Vixel Chat — full version
  - Presence: insert on login if needed (Option B)
  - presence table expected columns:
      id (uuid), username (text), lastseen (timestamp), online (bool), color (text), avatar (text)
    (Add color/avatar columns as TEXT in Supabase Table Editor)
  - Shift+Enter = newline, Enter = send
  - Players column shows properly and live
  - Go Offline & Clear Name removed per request
  - Less "meme" styling, more subdued theme
  - File intentionally verbose + commented (500+ lines)
-->

<style>
  :root{
    --bg: #050507;
    --panel: #0d0b0c;
    --panel2: #141213;
    --accent: #b72b2b;
    --muted: #9aa0a6;
    --text: #e9eef2;
    --card-radius: 12px;
    --avatar-size: 36px;
  }

  html,body{
    height:100%;
    margin:0;
    background: linear-gradient(180deg, var(--bg), #0b0607);
    color:var(--text);
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  /* Layout */
  .wrap{
    height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:16px;
    box-sizing:border-box;
  }

  .app{
    width:100%;
    max-width:1200px;
    height:86vh;
    display:grid;
    grid-template-columns: 3fr 1fr;
    gap:16px;
    min-height:0;
  }

  /* Card */
  .card{
    background: linear-gradient(180deg, var(--panel), var(--panel2));
    border-radius: var(--card-radius);
    padding:14px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    display:flex;
    flex-direction:column;
    border:1px solid rgba(255,255,255,0.03);
    min-height:0;
  }

  .headerRow{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }

  .title{
    font-weight:700;
    font-size:18px;
    letter-spacing:0.3px;
  }

  .subtitle{
    font-size:13px;
    color:var(--muted);
  }

  /* Messages */
  .messages {
    flex:1;
    overflow-y:auto;
    padding:12px;
    border-radius:10px;
    background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
    display:flex;
    flex-direction:column;
    gap:10px;
    min-height:0;
    scroll-behavior:smooth;
  }

  .msgRow{
    display:flex;
    gap:10px;
    align-items:flex-start;
    max-width:100%;
  }

  .avatar {
    width:var(--avatar-size);
    height:var(--avatar-size);
    min-width:var(--avatar-size);
    border-radius:50%;
    display:inline-grid;
    place-items:center;
    font-weight:700;
    color: #fff;
    text-transform:uppercase;
    box-shadow: 0 6px 16px rgba(0,0,0,0.45);
    flex-shrink:0;
    border:1px solid rgba(255,255,255,0.03);
  }

  .msg{
    padding:10px 12px;
    border-radius:10px;
    background: rgba(255,255,255,0.02);
    font-size:14px;
    line-height:1.4;
    max-width:88%;
    word-break:break-word;
    border:1px solid rgba(255,255,255,0.02);
    box-shadow: 0 2px 6px rgba(0,0,0,0.35);
  }

  .meta{
    font-size:12px;
    color:var(--muted);
    margin-bottom:6px;
  }

  .inputRow{
    display:flex;
    gap:8px;
    align-items:center;
    margin-top:10px;
  }

  textarea, input[type="text"]{
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
    color:var(--text);
    padding:10px;
    border-radius:8px;
    outline:none;
    flex:1;
    resize:vertical;
    min-height:40px;
    max-height:140px;
    font-size:14px;
  }

  .btn{
    background: linear-gradient(180deg, var(--accent), #8f2222);
    padding:10px 14px;
    border-radius:8px;
    border:none;
    color:white;
    cursor:pointer;
    font-weight:700;
    letter-spacing:0.3px;
  }

  /* Users column */
  .usersHeader{
    display:flex;
    align-items:center;
    justify-content:space-between;
    margin-bottom:8px;
  }

  .usersList{
    overflow:auto;
    flex:1;
    display:flex;
    flex-direction:column;
    gap:8px;
  }

  .userCard{
    display:flex;
    gap:10px;
    align-items:center;
    padding:8px;
    border-radius:8px;
    background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
    border:1px solid rgba(255,255,255,0.02);
  }

  .statusDot{
    width:10px;
    height:10px;
    border-radius:50%;
    margin-left:auto;
    box-shadow:0 1px 4px rgba(0,0,0,0.6);
  }
  .status-online{ background: #4be37a; }
  .status-offline{ background: #666; }

  .playersFooter{
    margin-top:8px;
    display:flex;
    gap:8px;
    align-items:center;
  }

  .mutedSmall{ color:var(--muted); font-size:13px; }

  @media (max-width:900px){
    .app{ grid-template-columns:1fr; height:92vh; }
    .users { order:-1; }
  }

  /* misc long comment block below to increase file length; file remains maintainable and commented */
  /* ---------------------------------------------------------------------------------------------- */
</style>
</head>
<body>
  <div class="wrap">
    <div class="app">

      <!-- Main chat -->
      <div class="card" id="mainCard">
        <div class="headerRow" style="margin-bottom:8px;">
          <div>
            <div class="title">Vixel Chat</div>
            <div class="subtitle">Realtime chat • subtle theme</div>
          </div>
          <div style="text-align:right;">
            <div class="mutedSmall" id="statusHint">not logged</div>
            <div class="mutedSmall" id="debugHint" style="margin-top:6px;">debug: idle</div>
          </div>
        </div>

        <div id="messages" class="messages" aria-live="polite" role="log"></div>

        <!-- message input: textarea to support multi-line + Shift+Enter newline -->
        <div class="inputRow">
          <textarea id="messageInput" placeholder="Write a message — Shift+Enter for newline, Enter to send"></textarea>
          <button id="sendBtn" class="btn">Send</button>
        </div>

        <!-- login row: insert presence if missing when user sets name -->
        <div style="margin-top:12px; display:flex; gap:8px; align-items:center;">
          <input id="nameInput" placeholder="Your name" style="padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); background:transparent; color:var(--text); flex:1;" />
          <button id="loginBtn" class="btn">Set Name</button>
        </div>

        <div style="margin-top:12px; display:flex; gap:10px; align-items:center;">
          <div class="mutedSmall" id="messagesCount">messages: 0</div>
          <div class="mutedSmall">•</div>
          <div class="mutedSmall" id="playersCount">players: 0</div>
        </div>
      </div>

      <!-- Players -->
      <div class="card users" id="usersCard">
        <div class="usersHeader">
          <div style="font-weight:700">Players</div>
          <div class="mutedSmall" id="onlineCount">0 online</div>
        </div>

        <div id="usersList" class="usersList"></div>

        <div class="playersFooter">
          <div class="mutedSmall">auto online while active</div>
          <div style="flex:1"></div>
          <button id="refreshPlayersBtn" class="btn" style="background:linear-gradient(180deg,#3a3a3a,#1f1f1f);">Refresh</button>
        </div>
      </div>

    </div>
  </div>

<script type="module">
/*
  Full Vixel Chat JS — Revised per request
  - Presence insertion on new login (Option B)
  - Players list shows live
  - Removed Clear Name & Go Offline buttons
  - Shift+Enter newline; Enter sends
  - Save avatar/color (text columns) into presence on creation
  - Less meme visuals
  - Long file, heavy comments for clarity
*/

/* -----------------------
   Supabase client
   Replace URL / KEY if needed — I kept your earlier values.
------------------------*/
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const supabaseUrl = "https://ehciyxvbasqiiiurjuwu.supabase.co";
const supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVoY2l5eHZiYXNxaWlpdXJqdXd1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQwNzQzNTgsImV4cCI6MjA3OTY1MDM1OH0.yMZ8EqtPXJumjn2xHTXwG3jbWTNdDxrklYIkdXNcbQk";

const supabase = createClient(supabaseUrl, supabaseKey);

/* -----------------------
   DOM elements
------------------------*/
const messagesEl = document.getElementById("messages");
const messageInput = document.getElementById("messageInput");
const sendBtn = document.getElementById("sendBtn");
const nameInput = document.getElementById("nameInput");
const loginBtn = document.getElementById("loginBtn");
const usersList = document.getElementById("usersList");
const onlineCountEl = document.getElementById("onlineCount");
const statusHint = document.getElementById("statusHint");
const debugHint = document.getElementById("debugHint");
const messagesCountEl = document.getElementById("messagesCount");
const playersCountEl = document.getElementById("playersCount");
const refreshPlayersBtn = document.getElementById("refreshPlayersBtn");

/* -----------------------
   Local state
------------------------*/
let username = localStorage.getItem("vixel_user") || "";
let presenceId = localStorage.getItem("vixel_presence_id") || null;
let onlineUsers = {}; // map username -> { username, online, id, color, avatar }
let seenMessageIds = new Set();
let messagesChannel = null;
let presenceChannel = null;
let messageCount = 0;

/* -----------------------
   UTIL: avatars + deterministic color
   We'll store color (hex string) in presence.color and avatar (same hex) in presence.avatar
------------------------*/
function deterministicColorForName(name) {
  // simple consistent color generator from string
  const palette = ["#FF6B6B","#FF9F43","#FFD166","#4D96FF","#6BF178","#7C6BFF","#FF6BB2","#6BDFF1","#FFCF76","#B4A7FF"];
  if(!name) return palette[Math.floor(Math.random()*palette.length)];
  let h = 0;
  for (let i = 0; i < name.length; i++) {
    h = (h << 5) - h + name.charCodeAt(i);
    h = h & h;
  }
  const idx = Math.abs(h) % palette.length;
  return palette[idx];
}

function avatarElement(name, size = 36, colorHex = null) {
  const el = document.createElement("div");
  el.className = "avatar";
  const letter = (name||"?").charAt(0).toUpperCase();
  el.textContent = letter;
  const bg = colorHex || deterministicColorForName(name);
  el.style.background = bg;
  el.style.width = `${size}px`;
  el.style.height = `${size}px`;
  el.style.minWidth = `${size}px`;
  return el;
}

function escapeHtml(s){
  return String(s || "").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c]));
}

/* -----------------------
   UI helpers: messages
------------------------*/
function clearMessages() {
  messagesEl.innerHTML = "";
  seenMessageIds.clear();
  messageCount = 0;
  messagesCountEl.textContent = `messages: ${messageCount}`;
}

function addMessageToDom(row) {
  // Expect row: { id, user, text, created_at }
  if (row && row.id) {
    if (seenMessageIds.has(row.id)) return;
    seenMessageIds.add(row.id);
  }
  const container = document.createElement("div");
  container.className = "msgRow";

  const av = avatarElement(row.user || "?", 36, row.avatar || deterministicColorForName(row.user));
  container.appendChild(av);

  const box = document.createElement("div");
  box.className = "msg";

  const meta = document.createElement("div");
  meta.className = "meta";
  const ts = row.created_at ? new Date(row.created_at).toLocaleTimeString() : "";
  meta.innerHTML = `<strong>${escapeHtml(row.user || "anon")}</strong> · <span class="mutedSmall">${escapeHtml(ts)}</span>`;

  const text = document.createElement("div");
  // preserve newlines
  const safeText = escapeHtml(row.text || "").replace(/\n/g, "<br/>");
  text.innerHTML = safeText;

  box.appendChild(meta);
  box.appendChild(text);
  container.appendChild(box);

  messagesEl.appendChild(container);
  messageCount++;
  messagesCountEl.textContent = `messages: ${messageCount}`;
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

/* -----------------------
   Load messages from Supabase
------------------------*/
async function loadMessages(){
  debug("loadMessages()");
  try {
    const { data, error } = await supabase
      .from("messages")
      .select("id, user, text, created_at")
      .order("created_at", { ascending: true })
      .limit(500);

    if (error) throw error;

    clearMessages();
    data?.forEach(r => addMessageToDom(r));
    debug(`loaded ${data?.length || 0} messages`);
  } catch (err) {
    console.error("loadMessages err", err);
    debug("loadMessages err: " + (err.message || err));
  }
}

/* -----------------------
   Send message
   - Enter sends
   - Shift+Enter inserts newline (handled at keydown)
   - We insert and rely on realtime INSERT to populate; but we also render returned row if server responds
------------------------*/
async function sendMessage(){
  const text = messageInput.value.trim();
  if (!username) {
    alert("Set your name first");
    return;
  }
  if (!text) return;

  sendBtn.disabled = true;
  try {
    const { data, error } = await supabase
      .from("messages")
      .insert([{ user: username, text }])
      .select("id, user, text, created_at");

    if (error) throw error;

    // server returned inserted row(s)
    if (data && data[0]) {
      addMessageToDom(data[0]);
    }

    messageInput.value = "";
    messageInput.focus();
  } catch (err) {
    console.error("sendMessage err", err);
    debug("sendMessage err: " + (err.message || err));
    alert("Failed to send message");
  } finally {
    sendBtn.disabled = false;
  }
}

/* -----------------------
   Presence: insert or update
   Behavior requested: Option B — insert if not exists when user logs in
   We'll store avatar & color fields in presence (both text)
------------------------*/
async function ensurePresenceRow(name) {
  if (!name) return;
  try {
    // try select for existing row
    const { data: existing, error: selectErr } = await supabase
      .from("presence")
      .select("id, username, online, color, avatar")
      .eq("username", name)
      .limit(1);

    if (selectErr) {
      // if select fails, continue to attempt insert or update
      console.warn("presence selectErr", selectErr);
    }

    if (existing && existing.length > 0) {
      presenceId = existing[0].id;
      localStorage.setItem("vixel_presence_id", presenceId);
      // update to mark online if needed
      await supabase
        .from("presence")
        .update({ online: true })
        .eq("id", presenceId)
        .select()
      ;
      return;
    }

    // if we got here, no existing row — build avatar/color and insert
    const color = deterministicColorForName(name);
    const avatar = color; // store same hex for avatar background; you can change format later
    const { data: inserted, error: insertErr } = await supabase
      .from("presence")
      .insert([{ username: name, online: true, color, avatar }])
      .select("id, username, online, color, avatar");

    if (insertErr) {
      // if insert fails due to race, try update fallback
      console.warn("presence insertErr", insertErr);
      // fallback attempt to update by username
      await supabase.from("presence").update({ online:true }).eq("username", name);
      const { data: fallback, error: fbErr } = await supabase.from("presence").select("id").eq("username", name).limit(1);
      if (fbErr) console.warn("presence fallback read err", fbErr);
      if (fallback && fallback.length > 0) {
        presenceId = fallback[0].id;
        localStorage.setItem("vixel_presence_id", presenceId);
      }
      return;
    }

    if (inserted && inserted[0]) {
      presenceId = inserted[0].id;
      localStorage.setItem("vixel_presence_id", presenceId);
    }
  } catch (err) {
    console.error("ensurePresenceRow err", err);
    debug("ensurePresenceRow err: " + (err.message || err));
  }
}

async function setOnline(name) {
  if (!name) return;
  try {
    await supabase.from("presence").update({ online: true }).eq("username", name);
  } catch (err) {
    console.warn("setOnline err", err);
  }
}

async function setOffline(name) {
  if (!name) return;
  try {
    await supabase.from("presence").update({ online: false }).eq("username", name);
  } catch (err) {
    console.warn("setOffline err", err);
  }
}

/* -----------------------
   Load presence list (players)
------------------------*/
async function loadPresence(){
  debug("loadPresence()");
  try {
    const { data, error } = await supabase
      .from("presence")
      .select("id, username, online, color, avatar");

    if (error) throw error;

    onlineUsers = {};
    (data || []).forEach(r => {
      onlineUsers[r.username] = {
        username: r.username,
        online: r.online,
        id: r.id,
        color: r.color || deterministicColorForName(r.username),
        avatar: r.avatar || (r.color || deterministicColorForName(r.username))
      };
    });

    renderPlayers();
    debug("loaded presence rows: " + (data?.length || 0));
  } catch (err) {
    console.error("loadPresence err", err);
    debug("loadPresence err: " + (err.message || err));
  }
}

function renderPlayers(){
  usersList.innerHTML = "";
  const arr = Object.values(onlineUsers).sort((a,b) => {
    if (a.online === b.online) return a.username.localeCompare(b.username);
    return a.online ? -1 : 1;
  });

  arr.forEach(u => {
    const card = document.createElement("div");
    card.className = "userCard";

    const av = avatarElement(u.username, 34, u.avatar || u.color);
    card.appendChild(av);

    const nameEl = document.createElement("div");
    nameEl.textContent = u.username;
    nameEl.style.fontWeight = 600;
    card.appendChild(nameEl);

    const dot = document.createElement("div");
    dot.className = "statusDot " + (u.online ? "status-online" : "status-offline");
    card.appendChild(dot);

    usersList.appendChild(card);
  });

  const onlineCount = arr.filter(u => u.online).length;
  onlineCountEl.textContent = `${onlineCount} online`;
  playersCountEl.textContent = `players: ${arr.length}`;
}

/* -----------------------
   Realtime subscriptions
   - messages INSERT: add to DOM (dedupe by id)
   - presence INSERT/UPDATE/DELETE: keep players list live
------------------------*/
function subscribeRealtime(){
  if (messagesChannel || presenceChannel) return;

  messagesChannel = supabase
    .channel('realtime:messages')
    .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, payload => {
      if (payload && payload.new) {
        // ensure we attach avatar color if we can — optional: presence join not available here
        addMessageToDom(payload.new);
      }
    })
    .subscribe(status => debug("messages channel: " + status));

  presenceChannel = supabase
    .channel('realtime:presence')
    .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'presence' }, payload => {
      const r = payload.new;
      if (!r || !r.username) return;
      onlineUsers[r.username] = { username: r.username, online: r.online, id: r.id, color: r.color, avatar: r.avatar };
      renderPlayers();
    })
    .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'presence' }, payload => {
      const r = payload.new;
      if (!r || !r.username) return;
      onlineUsers[r.username] = { username: r.username, online: r.online, id: r.id, color: r.color, avatar: r.avatar };
      renderPlayers();
    })
    .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'presence' }, payload => {
      const r = payload.old;
      if (!r || !r.username) return;
      delete onlineUsers[r.username];
      renderPlayers();
    })
    .subscribe(status => debug("presence channel: " + status));
}

/* -----------------------
   Event wiring
------------------------*/
loginBtn.onclick = async () => {
  const name = nameInput.value.trim();
  if (!name) { alert("Type a name"); return; }
  username = name;
  localStorage.setItem("vixel_user", username);
  nameInput.value = "";
  statusHint.textContent = `logged as ${username}`;

  // Option B: ensure presence row exists, then mark online
  await ensurePresenceRow(username);
  await setOnline(username);

  // subscribe & refresh
  subscribeRealtime();
  await loadPresence();
  await loadMessages();
};

sendBtn.onclick = sendMessage;
messageInput.addEventListener("keydown", async (e) => {
  // Shift+Enter should insert newline; Enter (no shift) should send
  if (e.key === "Enter") {
    if (e.shiftKey) {
      // let it add newline
      return;
    } else {
      e.preventDefault();
      await sendMessage();
    }
  }
});

// refresh players
refreshPlayersBtn.onclick = async () => {
  await loadPresence();
};

/* -----------------------
   Visibility & unload handling
   - mark offline when hidden/unload
   - mark online when visible
------------------------*/
window.addEventListener("beforeunload", async () => {
  if (username) {
    // best-effort set offline; we don't await due to unload
    try {
      // try sendBeacon alternative (note: Supabase requires headers; sendBeacon may not authenticate)
      // Primary approach: spawn an async update (best-effort)
      setTimeout(() => setOffline(username), 0);
    } catch(e){}
  }
});

document.addEventListener("visibilitychange", async () => {
  if (document.visibilityState === "hidden") {
    if (username) await setOffline(username).catch(()=>{});
    statusHint.textContent = username ? `hidden` : `not logged`;
  } else {
    if (username) {
      await ensurePresenceRow(username).catch(()=>{});
      await setOnline(username).catch(()=>{});
    }
    subscribeRealtime();
    await loadPresence();
    await loadMessages();
    statusHint.textContent = username ? `logged as ${username}` : `not logged`;
  }
});

/* -----------------------
   Init
------------------------*/
async function init(){
  debug("init start");
  if (username) {
    statusHint.textContent = `logged as ${username}`;
    // ensure presence exists and set online
    await ensurePresenceRow(username);
    await setOnline(username);
  } else {
    statusHint.textContent = "not logged";
  }

  subscribeRealtime();
  await loadPresence();
  await loadMessages();
  debug("init done");
}

init();

/* -----------------------
   Heartbeat to reduce false offline states (25s)
   - re-assert online periodically
------------------------*/
setInterval(async () => {
  if (username) {
    await setOnline(username).catch(()=>{});
  }
}, 25000);

/* -----------------------
   Debug helper
------------------------*/
function debug(msg){
  try {
    debugHint.textContent = "debug: " + String(msg).slice(0, 120);
    console.debug("[vixel-debug]", msg);
  } catch(e){}
}

/* -----------------------
   End of JS
------------------------*/
</script>

<!--
  End of file.
  Notes:
  - Add columns in Supabase presence table:
      color (text)
      avatar (text)
    Both should be TEXT. They store hex color strings for avatar background.
  - If you want messages to show avatar colors per-sender, we attempted to use presence.avatar when available;
    if you want message rows to include avatar color from presence, we could join presence on messages in the SELECT,
    but that requires a view or an extra lookup — currently we use deterministicColorForName when presence.avatar missing.
  - If something still doesn't show, check your Supabase table row permissions / CORS / anon key validity.
-->

</body>
</html>
