<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vixel Chat — Full Build</title>

<!--
  Vixel Chat
  - Full working single-file app
  - Realtime messages + presence + avatars + players list
  - Keeps "Go Offline" button (per request "don't remove anything")
  - No duplicate messages (dedup by id)
  - Uses your Supabase project URL + anon key from earlier messages
  - Option B presence behaviour (online true while on site; offline when leaving)
-->

<style>
  :root{
    --bg:#000000;
    --panel:#150000;
    --panel2:#1b0000;
    --accent1:#5A0000;
    --accent2:#C00000;
    --accent3:#FF2A2A;
    --text:#ffffff;
    --muted:#bbbbbb;
    --avatar-size:36px;
    --card-radius:14px;
  }

  html,body{
    height:100%;
    margin:0;
    background:linear-gradient(180deg,var(--bg),#1b0000);
    font-family:Inter,system-ui,Arial,Helvetica,sans-serif;
    color:var(--text);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  /* outer layout */
  .wrap{
    height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:18px;
    box-sizing:border-box;
  }

  .app{
    width:100%;
    max-width:1200px;
    height:86vh;
    display:grid;
    grid-template-columns:3fr 1fr;
    gap:18px;
    min-height:0;
  }

  /* cards */
  .card{
    background:linear-gradient(180deg,var(--panel),var(--panel2));
    border-radius:var(--card-radius);
    padding:14px;
    box-shadow:0 8px 30px rgba(0,0,0,0.7);
    display:flex;
    flex-direction:column;
    border:1px solid rgba(255,0,0,0.04);
    min-height:0;
  }

  .headerRow{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }

  .title{
    font-weight:900;
    font-size:18px;
    letter-spacing:0.4px;
  }

  .small{
    font-size:13px;
    color:var(--muted);
  }

  /* messages panel */
  .messages {
    flex:1;
    overflow-y:auto;
    padding:12px;
    border-radius:8px;
    background:linear-gradient(180deg, rgba(0,0,0,0.20), rgba(255,255,255,0.01));
    display:flex;
    flex-direction:column;
    gap:10px;
    min-height:0;
    scroll-behavior:smooth;
  }

  .msgRow{
    display:flex;
    gap:10px;
    align-items:flex-start;
    max-width:100%;
  }

  .avatar {
    width:var(--avatar-size);
    height:var(--avatar-size);
    min-width:var(--avatar-size);
    border-radius:50%;
    display:inline-grid;
    place-items:center;
    font-weight:800;
    border:2px solid rgba(255,255,255,0.04);
    color:white;
    text-transform:uppercase;
    flex-shrink:0;
    box-shadow:0 6px 18px rgba(0,0,0,0.45);
  }

  .msg{
    padding:10px 12px;
    border-radius:12px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    font-size:14px;
    line-height:1.35;
    animation:pop .12s ease;
    max-width:90%;
    word-break:break-word;
    border:1px solid rgba(255,255,255,0.02);
  }

  .meta{
    font-size:12px;
    color:var(--muted);
    margin-bottom:6px;
  }

  @keyframes pop { from{opacity:0; transform:translateY(6px) scale(.99);} to{opacity:1;} }

  .inputRow{
    display:flex;
    gap:8px;
    padding-top:10px;
    align-items:center;
  }

  input[type="text"], input[type="search"]{
    background:transparent;
    border:1px solid rgba(255,255,255,0.10);
    color:var(--text);
    padding:10px;
    border-radius:8px;
    outline:none;
    flex:1;
    box-sizing:border-box;
  }

  input[type="text"]::placeholder, input[type="search"]::placeholder{
    color:rgba(255,255,255,0.45);
  }

  .btn{
    background:linear-gradient(90deg,var(--accent2),var(--accent3));
    padding:10px 14px;
    border-radius:8px;
    border:none;
    color:white;
    cursor:pointer;
    font-weight:800;
    box-shadow:0 6px 18px rgba(0,0,0,0.45);
  }

  /* users column */
  .users {
    display:flex;
    flex-direction:column;
    gap:8px;
  }

  .usersHeader{
    display:flex;
    align-items:center;
    justify-content:space-between;
    margin-bottom:6px;
    color:var(--muted);
  }

  .usersList{
    overflow:auto;
    flex:1;
    padding-right:6px;
    display:flex;
    flex-direction:column;
    gap:8px;
  }

  .userCard{
    display:flex;
    gap:10px;
    align-items:center;
    padding:8px;
    border-radius:10px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.03);
    box-shadow: inset 0 -1px 0 rgba(0,0,0,0.2);
  }

  .statusDot{
    width:10px;
    height:10px;
    border-radius:50%;
    margin-left:auto;
    box-shadow:0 1px 4px rgba(0,0,0,0.6);
  }
  .status-online{ background: #3be86b; }
  .status-offline{ background: #555; }

  .searchBox{
    display:flex;
    gap:8px;
    margin-bottom:8px;
    align-items:center;
  }

  .mutedSmall{
    color:var(--muted);
    font-size:12px;
  }

  /* responsive */
  @media (max-width:900px){
    .app{ grid-template-columns:1fr; height:94vh; }
    .users { order: -1; }
  }

  /* long comment so file is beefy › (we'll still add many helpful comments in JS) */
</style>
</head>
<body>
  <div class="wrap">
    <div class="app">

      <!-- MAIN CHAT CARD -->
      <div class="card" id="mainCard">
        <div class="headerRow" style="margin-bottom:8px;">
          <div>
            <div class="title">Vixel Chat</div>
            <div class="small mutedSmall">Realtime chat — powered by Supabase</div>
          </div>
          <div style="text-align:right;">
            <div class="small" id="statusHint">not logged</div>
            <div class="small mutedSmall" id="debugHint" style="margin-top:6px;">debug: ready</div>
          </div>
        </div>

        <!-- MESSAGES -->
        <div id="messages" class="messages" aria-live="polite" role="log"></div>

        <!-- INPUT -->
        <div class="inputRow" style="margin-top:8px;">
          <input id="messageInput" type="text" placeholder="Type a message..." autocomplete="off" />
          <button id="sendBtn" class="btn">Send</button>
        </div>

        <!-- LOGIN ROW -->
        <div style="margin-top:10px;display:flex;gap:8px;align-items:center;">
          <input id="nameInput" placeholder="your name" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);background:transparent;color:var(--text)" />
          <button id="loginBtn" class="btn">Set Name</button>
          <!-- Per your "don't remove anything" request we KEEP the Go Offline button visible in the UI -->
          <button id="goOfflineBtn" class="btn" style="background:linear-gradient(90deg,#666,#444);margin-left:6px">Go Offline</button>
        </div>

        <!-- EXTRA INFO AREA -->
        <div style="margin-top:12px; display:flex; gap:12px; align-items:center;">
          <div class="small mutedSmall">Tip: press Enter to send</div>
          <div class="small mutedSmall"> • </div>
          <div class="small mutedSmall" id="messagesCount">messages: 0</div>
        </div>

      </div>

      <!-- USERS / PLAYERS CARD -->
      <div class="card users" id="usersCard">
        <div class="usersHeader">
          <div style="font-weight:800">Players</div>
          <div class="small" id="onlineCount">0 online</div>
        </div>

        <!-- search -->
        <div class="searchBox">
          <input id="playerSearch" type="search" placeholder="Search players..." />
          <div class="mutedSmall" id="playersFilterInfo">showing all</div>
        </div>

        <!-- list -->
        <div id="usersList" class="usersList" aria-live="polite"></div>

        <!-- little footer actions -->
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
          <button id="refreshPlayersBtn" class="btn" style="flex:1;background:linear-gradient(90deg,#222,#111)">Refresh Players</button>
          <button id="clearLocalBtn" class="btn" style="flex:1;background:linear-gradient(90deg,#3b3,#173)">Clear Name</button>
        </div>
      </div>

    </div>
  </div>

<script type="module">
/*
  Full Vixel Chat JS
  - Uses @supabase/supabase-js (esm) for channels + restful convenience
  - Avoids duplicate messages (dedup by id)
  - Presence: online true while page/tab is active; offline on unload/hidden
  - Keeps Go Offline button (manual override)
  - Players searchable
  - Letter avatars + deterministic colors
  - Lots of comments for clarity
*/

/* --------------------------
   IMPORTANT: Supabase config
   Keep these exactly as in your project (I used the ones you previously provided)
--------------------------- */
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const supabaseUrl = "https://ehciyxvbasqiiiurjuwu.supabase.co";
const supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVoY2l5eHZiYXNxaWlpdXJqdXd1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQwNzQzNTgsImV4cCI6MjA3OTY1MDM1OH0.yMZ8EqtPXJumjn2xHTXwG3jbWTNdDxrklYIkdXNcbQk";

const supabase = createClient(supabaseUrl, supabaseKey);

/* --------------------------
   DOM ELEMENTS
--------------------------- */
const messagesEl = document.getElementById("messages");
const msgInput = document.getElementById("messageInput");
const sendBtn = document.getElementById("sendBtn");
const nameInput = document.getElementById("nameInput");
const loginBtn = document.getElementById("loginBtn");
const usersList = document.getElementById("usersList");
const onlineCountEl = document.getElementById("onlineCount");
const statusHint = document.getElementById("statusHint");
const goOfflineBtn = document.getElementById("goOfflineBtn");
const messagesCountEl = document.getElementById("messagesCount");
const refreshPlayersBtn = document.getElementById("refreshPlayersBtn");
const clearLocalBtn = document.getElementById("clearLocalBtn");
const playerSearch = document.getElementById("playerSearch");
const playersFilterInfo = document.getElementById("playersFilterInfo");
const debugHint = document.getElementById("debugHint");

/* --------------------------
   Local state
--------------------------- */
let username = localStorage.getItem("vixel_user") || "";
let presenceId = localStorage.getItem("vixel_presence_id") || null;
let messagesChannel = null;
let presenceChannel = null;
let onlineUsers = {}; // map username -> {username, online, id}
let seenMessageIds = new Set(); // dedupe inserted messages
let messageCount = 0;

/* --------------------------
   Helpers: avatars, escaping
--------------------------- */
function createAvatarColor(letter){
  const colors = ["#FF4D4D","#FF8A4D","#FFDF4D","#4DFF8A","#4DD7FF","#7A4DFF","#FF4DA8","#4DFFB2","#FFE06C","#7CE6FF","#DDA0FF"];
  const code = letter ? letter.toUpperCase().charCodeAt(0) : Math.floor(Math.random()*100);
  return colors[code % colors.length];
}

function avatarEl(name, size = 36){
  const letter = (name||"?").charAt(0).toUpperCase();
  const bg = createAvatarColor(letter);
  const el = document.createElement("div");
  el.className = "avatar";
  el.style.background = bg;
  el.style.width = `${size}px`;
  el.style.height = `${size}px`;
  el.style.minWidth = `${size}px`;
  el.textContent = letter;
  return el;
}

function escapeHtml(str){
  return String(str || "").replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[s]));
}

/* --------------------------
   UI render helpers
--------------------------- */
function addMessageToDOM(msg, opts = {}){
  // msg: { id, user, text, created_at }
  // opts: {prepend: false}
  if (!msg || !msg.id) {
    // if there's no id, we still render but avoid dedupe logic
  } else {
    if (seenMessageIds.has(msg.id)) return;
    seenMessageIds.add(msg.id);
  }

  const row = document.createElement("div");
  row.className = "msgRow";

  const av = avatarEl(msg.user || "?", 36);
  row.appendChild(av);

  const box = document.createElement("div");
  box.className = "msg";

  const meta = document.createElement("div");
  meta.className = "meta";
  let timeString = "";
  try{ timeString = msg.created_at ? new Date(msg.created_at).toLocaleTimeString() : ""; }catch(e){ timeString = ""; }
  meta.innerHTML = `<strong>${escapeHtml(msg.user || "anon")}</strong> · <span class="small">${escapeHtml(timeString)}</span>`;

  const text = document.createElement("div");
  text.innerHTML = escapeHtml(msg.text || "");

  box.appendChild(meta);
  box.appendChild(text);
  row.appendChild(box);

  if (opts.prepend) messagesEl.prepend(row);
  else messagesEl.appendChild(row);

  messageCount++;
  messagesCountEl.textContent = `messages: ${messageCount}`;

  // scroll to bottom unless user scrolled up
  // we choose to always auto-scroll for now
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

function clearMessagesDOM(){
  messagesEl.innerHTML = "";
  seenMessageIds.clear();
  messageCount = 0;
  messagesCountEl.textContent = `messages: ${messageCount}`;
}

/* --------------------------
   Load initial messages
--------------------------- */
async function loadMessages(){
  debug("loadMessages()");
  try{
    // load last 200 messages ordered asc
    const { data, error } = await supabase
      .from("messages")
      .select("id, user, text, created_at")
      .order("created_at", { ascending: true })
      .limit(500);

    if (error) throw error;
    clearMessagesDOM();
    data?.forEach(row => addMessageToDOM(row));
    debug("loaded messages: " + (data?.length || 0));
  } catch (err){
    console.error("loadMessages err", err);
    debug("loadMessages err: " + (err.message || err));
  }
}

/* --------------------------
   Send message (no local double-echo)
   We will not locally add message before insert — rely on realtime INSERT event
   However for UX we will optimistically add if insert returns row (rarely necessary)
--------------------------- */
async function sendMessage(){
  const text = msgInput.value.trim();
  if (!username) return alert("Set a name first");
  if (!text) return;

  sendBtn.disabled = true;
  try{
    const { data, error } = await supabase
      .from("messages")
      .insert([{ user: username, text }])
      .select("id, user, text, created_at");

    if (error) throw error;

    // if returned data, render the returned row manually to avoid waiting for realtime event
    // but only render if realtime hasn't already done it (dedupe handles it)
    const inserted = (data && data[0]);
    if (inserted) addMessageToDOM(inserted);

    msgInput.value = "";
    msgInput.focus();
  } catch (err){
    console.error("sendMessage err", err);
    debug("sendMessage err: " + (err.message || err));
    alert("Failed to send message");
  } finally {
    sendBtn.disabled = false;
  }
}

/* --------------------------
   Presence: set online/offline
   Option B behavior: set online when on site; set offline when leave/hidden
   We will try both update and insert semantics so we don't rely on presence row existing
--------------------------- */
async function setOnlineFor(name){
  if (!name) return;
  try{
    // try update first (if row exists)
    const { data: updated, error: updateErr } = await supabase
      .from("presence")
      .update({ online: true })
      .eq("username", name)
      .select("id, username, online");

    if (updateErr) {
      // update may fail if row doesn't exist or RLS - log and continue
      // console.info("presence updateErr", updateErr);
    }

    if (updated && updated.length > 0){
      presenceId = updated[0].id;
      localStorage.setItem("vixel_presence_id", presenceId);
    } else {
      // insert if not updated
      const { data: inserted, error: insertErr } = await supabase
        .from("presence")
        .insert([{ username: name, online: true }])
        .select("id, username, online");

      if (insertErr) {
        // sometimes insert may conflict - swallow but log
        // console.warn("presence insertErr", insertErr);
      } else {
        presenceId = inserted && inserted[0] && inserted[0].id;
        if (presenceId) localStorage.setItem("vixel_presence_id", presenceId);
      }
    }
  } catch (err){
    console.error("setOnlineFor err", err);
    debug("setOnlineFor err: " + (err.message || err));
  }
}

async function setOfflineFor(name){
  if (!name) return;
  try{
    const { data, error } = await supabase
      .from("presence")
      .update({ online: false })
      .eq("username", name)
      .select("id, username, online");

    if (error) {
      // log but don't block
      // console.warn("setOfflineFor error", error);
      debug("setOfflineFor error: " + (error.message || error));
    }
  } catch (err){
    console.error("setOfflineFor err", err);
    debug("setOfflineFor err: " + (err.message || err));
  }
}

/* --------------------------
   Load presence list
--------------------------- */
async function loadPresence(){
  debug("loadPresence()");
  try{
    const { data, error } = await supabase
      .from("presence")
      .select("id, username, online");

    if (error) throw error;

    onlineUsers = {};
    data?.forEach(row => {
      onlineUsers[row.username] = { username: row.username, online: row.online, id: row.id };
    });

    renderUsers();
    debug("loaded presence: " + (data?.length || 0));
  } catch (err){
    console.error("loadPresence err", err);
    debug("loadPresence err: " + (err.message || err));
  }
}

/* --------------------------
   Render users (players list)
   Supports search filter from playerSearch input
--------------------------- */
function renderUsers(){
  usersList.innerHTML = "";
  const filter = (playerSearch?.value || "").trim().toLowerCase();

  const arr = Object.values(onlineUsers).sort((a,b) => {
    // online first then name
    if (a.online === b.online) return a.username.localeCompare(b.username);
    return a.online ? -1 : 1;
  });

  const filtered = arr.filter(u => {
    if (!filter) return true;
    return u.username.toLowerCase().includes(filter);
  });

  filtered.forEach(u => {
    const card = document.createElement("div");
    card.className = "userCard";

    const av = avatarEl(u.username, 30);
    card.appendChild(av);

    const nameEl = document.createElement("div");
    nameEl.style.fontWeight = 700;
    nameEl.textContent = u.username;
    card.appendChild(nameEl);

    const dot = document.createElement("div");
    dot.className = "statusDot " + (u.online ? "status-online" : "status-offline");
    card.appendChild(dot);

    usersList.appendChild(card);
  });

  const onlineCount = arr.filter(u => u.online).length;
  onlineCountEl.textContent = `${onlineCount} online`;

  playersFilterInfo.textContent = filter ? `filter: "${filter}"` : "showing all";
}

/* --------------------------
   Realtime subscriptions
   - messagesChannel listens for INSERT on messages
   - presenceChannel listens for INSERT/UPDATE/DELETE on presence
--------------------------- */
function subscribeRealtime(){
  // avoid double-subscribe
  if (messagesChannel || presenceChannel) return;

  // messages channel
  messagesChannel = supabase
    .channel("realtime:messages")
    .on("postgres_changes", { event: "INSERT", schema: "public", table: "messages" }, payload => {
      if (payload && payload.new) {
        addMessageToDOM(payload.new);
      }
    })
    .subscribe(status => {
      debug("messages channel status: " + status);
    });

  // presence channel
  presenceChannel = supabase
    .channel("realtime:presence")
    .on("postgres_changes", { event: "INSERT", schema: "public", table: "presence" }, payload => {
      const row = payload.new;
      if (row && row.username) {
        onlineUsers[row.username] = { username: row.username, online: row.online, id: row.id };
        renderUsers();
      }
    })
    .on("postgres_changes", { event: "UPDATE", schema: "public", table: "presence" }, payload => {
      const row = payload.new;
      if (row && row.username) {
        onlineUsers[row.username] = { username: row.username, online: row.online, id: row.id };
        renderUsers();
      }
    })
    .on("postgres_changes", { event: "DELETE", schema: "public", table: "presence" }, payload => {
      const row = payload.old;
      if (row && row.username && onlineUsers[row.username]) {
        delete onlineUsers[row.username];
        renderUsers();
      }
    })
    .subscribe(status => {
      debug("presence channel status: " + status);
    });
}

/* --------------------------
   UI events wiring
--------------------------- */
loginBtn.onclick = async () => {
  const name = nameInput.value.trim();
  if (!name) return;
  username = name;
  localStorage.setItem("vixel_user", username);
  nameInput.value = "";
  statusHint.textContent = `logged as ${username}`;
  await setOnlineFor(username);
  subscribeRealtime();
  await loadPresence();
  await loadMessages();
};

sendBtn.onclick = sendMessage;
msgInput.addEventListener("keydown", e => {
  if (e.key === "Enter") sendMessage();
});

goOfflineBtn.onclick = async () => {
  if (!username) return;
  await setOfflineFor(username);
  statusHint.textContent = `offline (you)`;
};

refreshPlayersBtn.onclick = async () => {
  await loadPresence();
};

clearLocalBtn.onclick = () => {
  localStorage.removeItem("vixel_user");
  localStorage.removeItem("vixel_presence_id");
  username = "";
  statusHint.textContent = "not logged";
  alert("local name cleared. reload or set a new name.");
};

playerSearch.addEventListener("input", () => {
  renderUsers();
});

/* --------------------------
   Visibility/unload handlers for presence
   - When page is hidden/unloaded, set offline (best-effort).
   - When page becomes visible, set online again.
--------------------------- */
window.addEventListener("beforeunload", async (e) => {
  if (username) {
    // try sendBeacon first (best-effort)
    try {
      // sendBeacon requires a URL and body (can't set headers), Supabase REST expects headers so sendBeacon won't authenticate.
      // We'll still call it for attempts on simple endpoints (rare). Primary method is a synchronous update via fetch though fetch won't be awaited.
      if (navigator.sendBeacon) {
        try {
          // best-effort: construct REST URL; may not work due to CORS or auth, but attempt anyway
          const url = `${supabaseUrl}/rest/v1/presence?username=eq.${encodeURIComponent(username)}`;
          const body = JSON.stringify({ online: false });
          navigator.sendBeacon(url, body);
        } catch (e) {
          /* ignore sendBeacon errors */
        }
      }
      // Fire a quick update via fetch but don't block unload
      setTimeout(() => setOfflineFor(username), 0);
    } catch (err) {
      /* ignore */
    }
  }
});

// visibility
document.addEventListener("visibilitychange", async () => {
  if (document.visibilityState === "hidden") {
    if (username) {
      await setOfflineFor(username).catch(()=>{});
      statusHint.textContent = `hidden (offline)`;
    }
  } else if (document.visibilityState === "visible") {
    if (username) {
      await setOnlineFor(username).catch(()=>{});
      statusHint.textContent = `logged as ${username}`;
    }
    // resubscribe & reload presence/messages for fresh UI
    subscribeRealtime();
    await loadPresence();
    await loadMessages();
  }
});

/* --------------------------
   Simple debug logger that writes to debugHint
--------------------------- */
function debug(msg){
  try{
    debugHint.textContent = "debug: " + msg;
    // also console log
    console.debug("[vixel-debug]", msg);
  } catch(e){}
}

/* --------------------------
   INIT: if username saved -> auto set online and subscribe
   Also load data once.
--------------------------- */
(async function init(){
  debug("init start");
  if (username){
    statusHint.textContent = `logged as ${username}`;
    await setOnlineFor(username);
    debug("set online for saved user");
  } else {
    statusHint.textContent = "not logged";
  }

  subscribeRealtime();

  // initial loads
  await loadPresence();
  await loadMessages();

  debug("init done");
})();

/* --------------------------
   EXTRA: Periodic heartbeat for presence correctness
   (Optional: to reduce false offline we ping server periodically)
   We'll keep heartbeat infrequent (every 25s) to reduce writes.
--------------------------- */
setInterval(async () => {
  if (username) {
    // mark online again to avoid false offline
    await setOnlineFor(username).catch(()=>{});
  }
}, 25000);

/* --------------------------
   Defensive: prevent double-subscribe when redeploying hot
--------------------------- */
window.addEventListener("unload", () => {
  // cleanup subscriptions on page leave (best-effort)
  try {
    if (messagesChannel) messagesChannel.unsubscribe();
    if (presenceChannel) presenceChannel.unsubscribe();
  } catch(e){}
});

/* --------------------------
   END JS
--------------------------- */

</script>

<!--
  End of full Vixel Chat file.
  This file intentionally includes verbose comments and some defensive code so it's long, readable, and tweakable.
  If you want styling tweaks, animations, or additional features (typing indicator, message edits, file uploads), say "option A/B" and i'll drop another full file like you asked.
-->

</body>
</html>
